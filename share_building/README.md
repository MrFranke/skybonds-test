# Долевое строительство
Online example: https://repl.it/repls/WhoppingSmoothLanguage

Запуск тестов: `npm run test`

### Сложность алгоритма
`O(n)` – линейная сложность

### Объем необходимой памяти для его выполнения
*Хочу сразу предупредить, что я ни разу до этого случая не считал объем
памяти, используемый алгоритмом, по этому все что описанно ниже лишь
мои предположения для движка V8 без учета окружения*
 
Входные данные представляют из себя массив строк, на каждый символ V8
выделяет 2 байта.

Переменная percent содержит number, под который выделяется 8 байт

В лямбда функции, переданной в reduce мы объявляем acc и item, где acc
это number (8) и item – это ссылка на элемент объявленного ранее массива и
для него уже выделенна память ранее.

В лямбде .map мы используем item (ссылка) и percent (ссылка), значит
не требуется выделение новой памяти

возвращаем массив string с 6ю символами на каждый элемент

Предположим что мы передали массив из n элементов, в каждом элементе 3 символа:

`(n*3*2) + 8 + n * 6 * 2 ` или `18n + 8`. Для 4х элементов это 80 байт

### Ограничения на размер входного массива, при котором алгоритм будет выполняться разумное время

К сожалению я не смог выполнить эту задачу.

Я [не могу заранее знать время выполнение алгоритма](https://ru.wikipedia.org/wiki/Проблема_остановки), 
с учетом окружения по этому я вижу несколько решений этой задачи:
1. Перед работой с реальными данными замерить время выполнения функции с тестовыми данными и делать
предположение на основе полученных метрик
2. Останавливать выполнение функции тогда, когда превысели выделенное время

Первый случая не надежен так как окружение может измениться в момент выполнения, второй случай не решает
задачу и не предсказывает заранее время выполнения алгоритма.
